## 12 함수

### 역사

최초의 프로그램은 루틴이라고 불렸다.

단일목록형태로 루틴을 관리하는 것은 굉장히 어려웠고, 동일한 명령어 목록이 여러 루틴에서 발견되기도 했다.

같은 루틴에서 같은 명령어 목록이 여러번 나왔다. 그래서 서브루틴이 만들어졌는데 **유용한 여러 서브루틴을 묶어서 라이브러리**라고 부르기로 했다. 각 서브루틴은 호출번호가 지정되었는데 도서관 책의 요청번호 같은 맥락이였는데 사치였다. 그레이스 호퍼는 A-0 이라고 명명된 루틴을 개발했는데 이게 최초 컴파일러이다.

컴파일러는 명령어 목록들과 호출 번호들, 그리고 서브루틴 라이브러리를 가지고 있는 테이프를 전달받아 처리했다. 호출번호와 연관된 서브루틴을 찾아서 새로운 프로그램에 집어넣었다. 다른 소스의 정보를 조립해서 프로그램을 만들어낸것이기에. 이때 어셈블러, 컴파일러, 라이브러리, 소스 , 호출(call)등 다양한 용어가 탄생.

… 역사 생략

function 연산자는 함수 객체를 만든다. function 연산자는 매개변수 목록과 문장 블록으로 구성된 함수 몸체를 전달받는다. 매개변수 목록에 있는 각각의 이름은 홤수 호출시 인자 목록으로 전달되는 표현식을 통해 초기화 될 변수들이다. 각각의 이름은 함수 호출 시 인자 목록으로 잔달되는 표현식을 통해 초기화될 변수들이다. 각각의 이름뒤에는 = 부호와 표현식이 올 수 있다. 이경우 인자로 전달되는 값이 undefined라면 대신 = 다음의 표현식값이 초기화에 사용된다.

```jsx
function make_set(array, value = true) {
	// 문자열 배열에서 속성이름을 가져와 객체를 만든다. 
	const object = Object.create(null);
	array.forEach(function (name) {
		object[name] = value;
	});
	return object;
}
```

함수객체는 인자 목록과 함께 호출되는데 인자목록에는 표현식이 없을수도 있고, 한개 이상의 표현식이 있을수도 있으며 각각은 쉼표(,)로 구분된다. 각 표현식은 계산된 뒤 함수의 매개변수에 지정된다.

인자목록과 매개변수 목록은 길이가 같지 않을수도 있다. 매개변수보다 긴 인자들은 함수에서 무시된다. 빠진 인자는 매개변수에 대해 undefined 값을 지정하게 된다.

확산연산자(…)는 인자목록이나 매개변수 목록에서 사용할 수 있다. 확산 연산자를 인자 목록에서 쓰면 전개(spread)문 이라고 부른다. 배열을 받아서 전개함으로써 배열의 각 요소가 구분된 인자처럼 잔달되도록 해준다. 매개변수 목록에서 쓰면 나머지(rest)문이 된다. 인자의 나머지가 하나의 배열로 묶여서 해당 매개변수 이름과 연결된다. 그래서 나머지문을 쓰는 매개변수 목록에서 반드시 마지막에 나와야한다. 함수는 나머지문을 써서 가변인자를 처리할 수 있다.

```jsx
function curry(func, ...zeroth) {
	return function (...wunth) {
		return func(...zeroth, ...wunth);
	};
}
```

함수가 호출되면 활성객체가 만들어진다. 활성객체는 눈에 보이지 않는다. 숨겨진 데이터 구조로서 호추로딘 함수의 반환주소와 실행에 필요한 정보를 저장하고, 이를 호출된 함수에 바인딩해준다.

자바스크립트에서는 활성객체를 다른 객체와 마찬가지로 **힙에 저장**한다(c같은 언어는 스택에 저장된다고 한다.)

함수가 종료된다고 활성객체를 자동으로 비활성화하지 않는다. 활성 객체는 해당 객체에 대한 참조가 있는 한 계속 살아있고, 다른객체와 마찬가지로 **가비지 컬렉터에 의해 처리된다.**

- 활성객체는 다음 정보를 가지고 있다.
    - 함수객체에 대한 참조
    - 함수를 호출한 측의 활성 객체에 대한 참조. 이 참조는 return 문이 실행 흐름을 함수 호출 측으로 돌릴때 사용한다.
    - 함수 호출이 끝난뒤 실행을 재개하기 위해 필요한 정보. 대개는 함수 호출문 바로 다음 명령어의 주소가 된다.
    - 인자에 의해 초기화 되는 함수 매개변수
    - undefined로 초기화된 함수 변수들
    - 함수가 복잡한 표현식을 계산하기 위해 임시로 사용하는 변수들
    - 함수 객체가 메서드로서 호출되었을때 사용할 수 있는 this 참조

함수객체는 다른 일반적인 객체와 마찬가지로 속성을 가지고 있으며 변경 할 수 있다. 이는 좋은점이 아니다.

함수 객체는 불변객체였어야만 한다. 일부 보안 시나리오에서는 공유되는 변경 가능한 함수 객체가 취약점으로 사용될 수 있다. 함수객체는 prototype이라는 속성을 가지고 있다. prototype은 특정상태에 있는 요소를 선택하기 위해 의사클래스모델에서 사용되는데 prototype을 권장하진 않는다. prototype속성은 Object.prototype에 대한 델리게이션 링크와 constructor 속성을 가진 객체의 참조를 가지고 있는데, constructor속성은 또한 함수 객체에 대한 역참조를 가지고 있다. (16장에서 다룬다)

함수객체는 Function.prototype에 대한 델리케이션 링크를 가지고 있다. 이 링크를 통해 함수객체는 필요없는 메서드인 apply, call을 상속받는다. 함수객체에는 두가지 속성이 숨겨져 있다.

- 함수 실행 코드에 대한 참조
- 함수 객체가 생성되는 시점에 활성화된 활성 객체에 대한 참조. 덕분에 클로저를 사용할 수 있다. 함수는 숨겨진 이 속성을 통해 함수를 만든 함수의 변수에 접근할 수 있다.

자유변수라는 용어는 함수가 함수 밖에 선언된 함수를 사용하는것을 위해 만들어진말(클로저랑 다를게 없는데…)

묶인변수는 매개변수를 포함해 함수 내부에 선언된 변수를 설명하는 말이다.

함수는 중첩될 수 잇다. 내부 함수 객체가 생성되면 이 객체는 자신을 생성한 외부 함수에 대한 활성객체의 참조를 가지게 된다. 이렇게 함수 객체가 외부 함수에 활성 객체의 참조를 가지는 방식을 클로저라한다.